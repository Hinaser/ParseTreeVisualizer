#region Notice
/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2016-2016 Rindo Hinase
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#endregion

#region using directive
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Reflection;

using System.IO;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;

using ErrorTuple = System.Tuple<Antlr4.Runtime.IRecognizer, Antlr4.Runtime.IToken, int, int, string, Antlr4.Runtime.RecognitionException>;
#endregion

namespace ParseTreeVisualizer
{
    /// <summary>
    /// A class which holds lexer and parser for a grammar.
    /// This CommonGrammar class does lex/parse a text written in target grammar syntax.
    /// After parsing the text, this can output parse tree representation in javascript.
    /// Example to use this common grammar:
    ///   using ParseTreeVisualizer;
    ///   ...
    ///   CommonGrammar cg = new CommonGrammar();
    ///   FileStream fs = new FileStream(path_of_file_to_be_parsed, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
    ///   StreamReader sr = new StreamReader(fs, fileEncoding);
    ///   cg.Initialize<SomeAntlr4Lexer, SomeAntlr4Parser>(sr);
    ///   cg.Parse("RootRuleName");
    ///   cg.WriteParseTree("parse-tree1.js", 65001)
    /// </summary>
    public class CommonGrammar
    {
        #region Fields
        protected AntlrInputStream InputStream;
        protected Lexer Lexer;
        protected Parser Parser;
        protected CommonTokenStream TokenStream;
        protected CommonErrorListener ErrorListner;
        protected IParseTreeListener ParseListener;
        protected IParseTree cst = null;
        protected TextReader TextReader;
        protected Type LexerType;
        protected Type ParserType;
        #endregion

        /// <summary>
        /// Initialize CommonGrammar class by inputting type of lexer/parser and source text to be parsed.
        /// Lexer/Parser class must be descendant of Antlr's Lexer/Parser class, which is generated by
        /// Antlr tool.
        /// Text to be parsed will be injected in the form of TextReader class. If you would like to parse content of some file,
        /// e.g. You can initialize by the code like below:
        ///   CommonGrammar cg = new CommonGrammar();
        ///   FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        ///   StreamReader sr = new StreamReader(fs, fileEncoding);
        ///   cg.Initialize<SomeLangLexer, SomeLangParser>(sr);
        /// </summary>
        /// <typeparam name="TLexer">Type of custom lexer class which is a descendant of Antlr's Lexer class</typeparam>
        /// <typeparam name="TParser">Type of custom parser class which is a descendant of Antlr's Parser class</typeparam>
        /// <param name="tr">An instance of a class that inherits TextReader class. i.e. StreamReader</param>
        public void Initialize<TLexer, TParser>(TextReader tr)
            where TLexer: Lexer
            where TParser: Parser
        {
            // Accept input lexer/parser generic type and source text stream to class instance field variables.
            this.TextReader = tr;
            this.LexerType = typeof(TLexer);
            this.ParserType = typeof(TParser);
            this.InputStream = new AntlrInputStream(tr);
            this.Lexer = (TLexer)Activator.CreateInstance(this.LexerType, this.InputStream);
            this.TokenStream = new CommonTokenStream(this.Lexer);
            this.TokenStream.Fill();
            this.Parser = (TParser)Activator.CreateInstance(this.ParserType, this.TokenStream);

            // Set error listener class. Error listener generated by `this.GetErrorListener()` would vary depending on 
            // inherited class implementation.
            this.ErrorListner = this.GetErrorListener();
            this.Parser.AddErrorListener(ErrorListner);
        }

        /// <summary>
        /// Initialize CommonGrammar class by inputting type of lexer/parser and source input file path and encoding
        /// which contains text to be parsed.
        /// Lexer/Parser class must be descendant of Antlr's Lexer/Parser class, which is generated by
        /// Antlr tool.
        /// </summary>
        /// <typeparam name="TLexer">Type of custom lexer class which is a descendant of Antlr's Lexer class</typeparam>
        /// <typeparam name="TParser">Type of custom parser class which is a descendant of Antlr's Parser class</typeparam>
        /// <param name="inputFilePath">Path of a file containing text to be parsed</param>
        /// <param name="codePage">Encoding of the file</param>
        public void Initialize<TLexer, TParser>(string inputFilePath, int codePage)
            where TLexer : Lexer
            where TParser : Parser
        {
            FileStream fs = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            StreamReader sr = new StreamReader(fs, Encoding.GetEncoding(codePage));
            Initialize<TLexer, TParser>(sr);
        }

        /// <summary>
        /// ErrorListener class used in parsing phase. This method is marked as `virtual`. So developer can override
        /// this method for custom error listener.
        /// </summary>
        /// <returns>ErrorListener instance</returns>
        protected virtual CommonErrorListener GetErrorListener()
        {
            if(this.ErrorListner == null)
                return new CommonErrorListener();

            return this.ErrorListner;
        }

        /// <summary>
        /// Check whether this common grammar class instance is initialized.
        /// If it is not initialized properly, this method raises an exception.
        /// </summary>
        protected void CheckInitialized()
        {
            if(Lexer == null || Parser == null)
            {
                throw new Exception();
            }
        }

        /// <summary>
        /// Execute parsing from specified rule with tree listener.
        /// This listener is not an error listener but tree listener.
        /// When parser enters/exits some of a rule listened by the listener,
        /// listener method will be invoked.
        /// </summary>
        /// <typeparam name="T">Type of a custom parse tree listener</typeparam>
        /// <param name="rule">Root rule name of parsing</param>
        /// <param name="listener">Instance of listener</param>
        /// <returns>Instance of parse tree</returns>
        public IParseTree Parse<T>(string rule, T listener)
            where T : IParseTreeListener
        {
            CheckInitialized();

            if (listener == null)
            {
                throw new NullReferenceException();
            }

            this.ParseListener = listener;

            // Try parsing by rule name.
            // When input rule name is "RootRule", actually `this.Parser.RootRule()` will be invoked.
            Type t = this.Parser.GetType();
            MethodInfo method = t.GetMethod(rule);
            this.cst = (ParserRuleContext)method.Invoke(this.Parser, null);

            // Walk parse tree nodes and invoke listener methods if necessary.
            ParseTreeWalker walker = new ParseTreeWalker();
            walker.Walk(this.ParseListener, this.cst);

            return this.cst;
        }

        /// <summary>
        /// Execute parsing by root rule name without tree listener.
        /// </summary>
        /// <param name="rule">Root rule name of parsing</param>
        /// <returns>Instance of parse tree</returns>
        public IParseTree Parse(string rule)
        {
            CheckInitialized();

            // Try parsing by rule name.
            // When input rule name is "RootRule", actually `this.Parser.RootRule()` will be invoked.
            Type t = this.Parser.GetType();
            MethodInfo method = t.GetMethod(rule);
            this.cst = (ParserRuleContext)method.Invoke(this.Parser, null);

            return this.cst;
        }

        /// <summary>
        /// Execute parsing. Root rule name is automatically detected
        /// </summary>
        /// <returns>Instance of parse tree</returns>
        public IParseTree Parse()
        {
            CheckInitialized();

            string rule = Parser.RuleNames[0];

            // Try parsing by rule name.
            // When input rule name is "RootRule", actually `this.Parser.RootRule()` will be invoked.
            Type t = this.Parser.GetType();
            MethodInfo method = t.GetMethod(rule);
            this.cst = (ParserRuleContext)method.Invoke(this.Parser, null);

            return this.cst;
        }

        /// <summary>
        /// Returns tree listener. Should be called after parsing is done.
        /// Otherwise, returning listener instance holds almost nothing.
        /// </summary>
        /// <returns>Instance of parse tree listener</returns>
        public virtual IParseTreeListener GetListener()
        {
            return ParseListener;
        }

        /// <summary>
        /// Get the javascript representation of parse tree.
        /// By loading the javascript string generated by this method into browser,
        /// Object called `CST` is attached to window global object.
        /// You can then visualize the generated parse tree in browser by inspecting this
        /// CST object.
        /// The CST javascript object specification is as follows:
        ///   CST.tree():
        ///     Data of parse tree in linked list structure.
        ///   CST.errors():
        ///     List of errors confirmed in parsing.
        ///   CST.tokens():
        ///     List of tokens composing parse tree.
        ///   CST.addRuleListener(function(node), ruleIndex):
        ///     Add listener to the rule node specified by `ruleIndex`. When `ruleIndex` parameter is empty, the rule listener
        ///     is attached to every rule node.
        ///       function(node): Listener function invoked when parse tree walker reaches target rule node.
        ///                       The parameter `node` has two types. Rule node and leaf node. Rule node is composed of leaf nodes
        ///                       and rule nodes, while leaf node is a terminal node and hold a lexical token.
        ///                       More description will be added in an appropriate time.
        ///       ruleIndex: Integer value of target rule. More description will be added in an appropriate time.
        ///   CST.walk():
        ///     Walk parse tree with rule listener added by the function above. Typically, this does nothing if
        ///     none of rule listeners are added. This method is used to construct DOM object visualizing parse tree in browser.
        ///     Example of constructing parse tree DOM representation is as follows:
        ///     Parse tree can be depicted by combination of <ul> tag and <li> tag. So at first define rule listener to make
        ///     nesting list and then walk. After walking is done, then insert the list DOM object to document in browser.
        /// </summary>
        /// <param name="tree">Parse tree instance generated by `Parse` method</param>
        /// <returns>Javascript code which has all the data required to visualize parse tree</returns>
        public string ToJsString(IParseTree tree = null)
        {
            // Using StringBuilder class to enhance performance
            StringBuilder leaves = new StringBuilder();
            StringBuilder rules = new StringBuilder();
            StringBuilder errors = new StringBuilder();

            int nRules = 0;
            int nLeaves = 0;

            // Main part to generate parse tree javascript text
            StringBuilder parseTree = makeParseTree(rules, ref nRules, leaves, ref nLeaves, tree);

            // Initialize code template string
            StringBuilder template = JsParseTeeFileTemplate();

            // Error list
            Regex regex0 = new Regex(@"[\\]");
            Regex regex1 = new Regex(@"""");
            string errorTemplate = "errors[{0}] = {1};\n";
            var errorList = GetErrors();
            for (int i = 0; i < errorList.Count; i++)
            {
                string errMsg = errorList[i].Item5;
                errMsg = regex0.Replace(errMsg, @"\\\\");
                errMsg = regex1.Replace(errMsg, @"\""");

                string errorObj = String.Format("{{line:{0}, pos:{1}, msg:\"{2}\"}}", errorList[i].Item3, errorList[i].Item4, errMsg);
                errors.AppendFormat(errorTemplate, i, errorObj);
            }

            parseTree.Replace("[r", "[\n\tr").Replace(",", ",\n\t").Replace("]]", "]\n]");
            return String.Format(template.ToString(), leaves, rules, errors, parseTree);
        }

        /// <summary>
        /// Make parse tree string representation. This method is recursive and not open to public.
        /// </summary>
        /// <param name="rules"></param>
        /// <param name="nRules"></param>
        /// <param name="leaves"></param>
        /// <param name="nLeaves"></param>
        /// <param name="tree"></param>
        /// <returns></returns>
        private StringBuilder makeParseTree(StringBuilder rules, ref int nRules, StringBuilder leaves, ref int nLeaves, IParseTree tree = null)
        {
            if (tree == null && this.cst == null)
            {
                return new StringBuilder();
            }
            else if (tree == null)
            {
                tree = this.cst;
            }

            StringBuilder builder = new StringBuilder();

            for (int i = 0; i < tree.ChildCount; i++)
            {
                if (i == 0) builder.Append("[");

                IParseTree child = tree.GetChild(i);

                if (child is ITerminalNode)
                {
                    string text = child.GetText();
                    text = SanitizeJsCode(text);

                    int tokenType = ((CommonToken)child.Payload).Type;
                    string varName = String.Format("tokens[{0}]", nLeaves++);
                    leaves.AppendFormat("{0} = {{l:{1},t:\"{2}\"}};\n", varName, tokenType, text);

                    builder.Append(varName);
                }
                else if (child is RuleContext)
                {
                    StringBuilder childTree = makeParseTree(rules, ref nRules, leaves, ref nLeaves, child);
                    if (childTree.Length < 1) childTree.Append("[]");

                    string varName = String.Format("rules[{0}]", nRules++);
                    rules.AppendFormat("{0} = {{r:{1},c:{2}}};\n", varName, ((RuleContext)child).RuleIndex, childTree.ToString());

                    builder.Append(varName);
                }

                if (i == tree.ChildCount - 1)
                {
                    builder.Append("]");
                }
                else
                {
                    builder.Append(",");
                }
            }

            return builder;
        }

        /// <summary>
        /// Generate Template of javascript code for parse tree data.
        /// </summary>
        /// <returns>Template of javascript code for parse tree with token names and rule names</returns>
        public StringBuilder JsParseTeeFileTemplate()
        {
            StringBuilder template = new StringBuilder();
            string code = "";

            StringBuilder sb = new StringBuilder();

            // Token names
            IVocabulary vocabulary = Lexer.Vocabulary;
            for (int i = 0; i < vocabulary.MaxTokenType; i++)
            {
                if (i < vocabulary.MaxTokenType - 1)
                {
                    sb.AppendFormat("{0}\"{1}\",{2}", "\t", vocabulary.GetSymbolicName(i), "\n");
                }
                else
                {
                    sb.AppendFormat("\t\"{0}\"", vocabulary.GetSymbolicName(i));
                }
            }
            String tokenNames = sb.ToString();

            // Rule names
            sb = new StringBuilder();
            for (int i = 0; i < Parser.RuleNames.Length; i++)
            {
                if (i < Parser.RuleNames.Length - 1)
                {
                    sb.AppendFormat("{0}\"{1}\",{2}", "\t", Parser.RuleNames[i], "\n");
                }
                else
                {
                    sb.AppendFormat("\t\"{0}\"", Parser.RuleNames[i]);
                }
            }
            String ruleNames = sb.ToString();

            code = @"(function(global, factory){{{{
  ""use strict"";
  factory(global);
}}}})(window, function(global){{{{
""use strict"";
var tokenNames = [
{0}
];
var ruleNames = [
{1}
];

var tokens = [];
var rules = [];
var errors = [];
var tree;

{{0}}

{{1}}

{{2}}

tree = {{3}};

var ruleListeners = [];
var everyListners = [];

var CST = {{{{
  tokenNames: function(n){{{{
    return tokenNames[n];
  }}}},
  ruleNames: function(n){{{{
    return ruleNames[n];
  }}}},
  tokens: function(){{{{
    return tokens;
  }}}},
  rules: function(){{{{
    return rules;
  }}}},
  errors: function(){{{{
    return errors;
  }}}},
  tree: function(){{{{
    return tree;
  }}}},
  addRuleListener: function(fn, ruleIndex){{{{
    if(!ruleIndex){{{{
      everyListners.push(fn);
    }}}}
    else{{{{
      if(ruleListeners[ruleIndex] === undefined) ruleListeners[ruleIndex] = [];
      ruleListeners[ruleIndex].push(fn);
    }}}}
  }}}},
  clearRuleListeners: function(){{{{
    ruleListeners = [];
    everyListners = [];
  }}}},
  walk: function(nodes){{{{
    if(!nodes){{{{
       nodes = [{{{{r: 0, c: tree}}}}];
       return CST.walk(nodes);
    }}}}
    for(var i=0; i<nodes.length; i++){{{{
      var isRule = nodes[i].hasOwnProperty('r');
      if(isRule){{{{
        var listeners = ruleListeners[nodes[i].r];
        if(listeners !== undefined) listeners.forEach(function(el, i, arr){{{{el(nodes[i])}}}});
        if(everyListners.length > 0) everyListners.forEach(function(el){{{{el(nodes[i])}}}});
        CST.walk(nodes[i].c);
      }}}}
    }}}}
  }}}}
}}}};

global.CST = CST;
}}}});
";

            template.AppendFormat(code, tokenNames, ruleNames);
            return template;
        }

        /// <summary>
        /// List of Error records found in parsing. A record will contain line number, position,
        /// error message and other informations for a parse error.
        /// </summary>
        /// <returns></returns>
        public List<ErrorTuple> GetErrors()
        {
            if (this.ErrorListner == null)
            {
                return null;
            }

            return this.ErrorListner.getListOfErrors();
        }

        private static Regex regex0 = new Regex(@"[\\]");
        private static Regex regex1 = new Regex(@"""");
        private static Regex regex2 = new Regex(@"([\r])");
        private static Regex regex3 = new Regex(@"([\n])");
        private static Regex regex4 = new Regex(@"([\t])");
        /// <summary>
        /// Static method for sanitizing javascript code.
        /// This will replace new line and tab, double quote, escape sequence to unharmful character.
        /// </summary>
        /// <param name="text">Text to be sanitized</param>
        /// <returns>Sanitized text</returns>
        private static String SanitizeJsCode(String text)
        {
            text = regex0.Replace(text, @"\\\\");
            text = regex1.Replace(text, @"\""");
            text = regex2.Replace(text, @"\r");
            text = regex3.Replace(text, @"\n");
            text = regex4.Replace(text, @"\t");

            return text;
        }

        /// <summary>
        /// List of tokens which is a result of lexer. This tokens is inrelevant to parser.
        /// So before doing parsing, this method will returns meaningful tokens.
        /// </summary>
        /// <returns>List of lexical tokens</returns>
        public IEnumerable<string> GetTokens()
        {
            return this.TokenStream.GetTokens().Select(i => i.ToString());
        }

        /// <summary>
        /// </summary>
        /// <returns>TokenStream in field variable</returns>
        public CommonTokenStream GetTokenStream()
        {
            return this.TokenStream;
        }

        /// <summary>
        /// Returns name of lexical token specified by token index number.
        /// </summary>
        /// <param name="tokenIndex">An integer value of token</param>
        /// <returns>String representation of a lexical token</returns>
        public string GetTokenTypeName(int tokenIndex)
        {
            return Lexer.Vocabulary.GetSymbolicName(tokenIndex);
        }

        /// <summary>
        /// Output list of lexical tokens to a file in tsv format.
        /// This method write text data always in UTF-8 format without BOM.
        /// To convert original input text to UTF8, this method requires code page of original input text.
        /// </summary>
        /// <param name="filepath">Path of a file to be written</param>
        /// <param name="codePage">
        /// Code page of SOURCE text to be written.
        /// Code page list: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx
        /// </param>
        public void WriteTokenList(string filepath, int codePage)
        {
            Encoding utf8 = new UTF8Encoding(false);

            using (StreamWriter sw = new StreamWriter(filepath, false, utf8))
            {
                // Add header
                sw.WriteLine(String.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}", "Token#", "Line", "StartByte", "EndByte", "Type", "Channel", "Text"));

                var tokenStream = GetTokenStream();
                var tokens = tokenStream.GetTokens();
                foreach (IToken token in tokens)
                {
                    if (token.Text == null)
                    {
                        continue;
                    }

                    string tokenText = token.Text;
                    tokenText = tokenText.Replace("\r", "\\r");
                    tokenText = tokenText.Replace("\n", "\\n");
                    tokenText = tokenText.Replace("\t", "\\t");
                    tokenText = tokenText.Replace("\"", "\\\"");

                    // Convert encoding to UTF-8
                    Encoding charset = Encoding.GetEncoding(codePage);
                    byte[] text = charset.GetBytes(tokenText);
                    text = Encoding.Convert(charset, utf8, text);
                    tokenText = utf8.GetString(text);

                    sw.WriteLine(String.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}",
                        token.TokenIndex,
                        token.Line,
                        token.StartIndex,
                        token.StopIndex,
                        token.Type > 0 ? GetTokenTypeName(token.Type) : "",
                        token.Channel,
                        tokenText
                        ));
                }
            }
        }

        /// <summary>
        /// Almost the same to the method `WriteTokenList`. The difference is that this method output the data in JSON format.
        /// </summary>
        /// <param name="filepath">Path of a file to be written</param>
        /// <param name="codePage">
        /// Code page of SOURCE text to be written.
        /// Code page list: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx
        /// </param>
        public void WriteTokenListAsJson(string filepath, int codePage)
        {
            Encoding utf8 = new UTF8Encoding(false);

            using (StreamWriter sw = new StreamWriter(filepath, false, utf8))
            {
                // First line
                sw.WriteLine("[");

                var tokenStream = GetTokenStream();
                var tokens = tokenStream.GetTokens();
                bool initial = true;

                foreach (IToken token in tokens)
                {
                    if (token.Text == null)
                    {
                        continue;
                    }

                    // Other than first iteration, add comma at first.
                    if (!initial)
                    {
                        sw.WriteLine(",");
                    }
                    else
                    {
                        initial = false;
                    }

                    string tokenText = token.Text;
                    tokenText = tokenText.Replace("\r", "\\r");
                    tokenText = tokenText.Replace("\n", "\\n");
                    tokenText = tokenText.Replace("\t", "\\t");
                    tokenText = tokenText.Replace("\"", "\\\"");

                    // Convert encoding to UTF-8
                    Encoding charset = Encoding.GetEncoding(codePage);
                    byte[] text = charset.GetBytes(tokenText);
                    text = Encoding.Convert(charset, utf8, text);
                    tokenText = utf8.GetString(text);

                    sw.Write("{");
                    sw.Write(String.Format("\"tid\": \"{0}\",", token.TokenIndex));
                    sw.Write(String.Format("\"ln\": \"{0}\",", token.Line));
                    sw.Write(String.Format("\"st\": \"{0}\",", token.StartIndex));
                    sw.Write(String.Format("\"en\": \"{0}\",", token.StopIndex));
                    sw.Write(String.Format("\"ty\": \"{0}\",", token.Type > 0 ? GetTokenTypeName(token.Type) : ""));
                    sw.Write(String.Format("\"ch\": \"{0}\",", token.Channel));
                    sw.Write(String.Format("\"txt\": \"{0}\"", tokenText));
                    sw.Write("}");
                }

                // Last line
                sw.WriteLine("]");
            }
        }

        /// <summary>
        /// Output list of errors into a file if it exists. When there are no errors, 0-byte file will be generated.
        /// </summary>
        /// <param name="filepath">Path of a file to be written</param>
        public void WriteErrors(string filepath)
        {
            Encoding utf8 = new UTF8Encoding(false);

            using (StreamWriter sw = new StreamWriter(filepath, false, utf8))
            {
                var errors = GetErrors();

                // When no errors found, write nothing.
                if (errors.Count < 1)
                {
                    return;
                }

                // Add header
                sw.WriteLine(String.Format("{0}\t{1}\t{2}", "Line", "Position", "Message"));

                foreach (var error in errors)
                {
                    sw.WriteLine(String.Format("{0}\t{1}\t{2}",
                        error.Item3,
                        error.Item4,
                        error.Item5
                        ));
                }
            }
        }

        /// <summary>
        /// Output parse tree data in javascript code.
        /// </summary>
        /// <param name="filepath">Path of a file to be written</param>
        /// <param name="codePage">
        /// Code page of SOURCE text to be written.
        /// Code page list: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx
        /// </param>
        public void WriteParseTree(string filepath, int codePage)
        {
            Encoding utf8 = new UTF8Encoding(false);

            using (StreamWriter sw = new StreamWriter(filepath, false, utf8))
            {
                string JsonPtree = ToJsString();

                Encoding charset = Encoding.GetEncoding(codePage);
                byte[] text = charset.GetBytes(JsonPtree);
                text = Encoding.Convert(charset, utf8, text);
                JsonPtree = utf8.GetString(text);

                sw.Write(JsonPtree);
            }
        }
    }

    /// <summary>
    /// Custom error listener to store Syntax errors.
    /// </summary>
    public class CommonErrorListener : BaseErrorListener
    {
        protected List<ErrorTuple> SyntaxErrorList = new List<ErrorTuple>();

        public override void SyntaxError(
            IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e)
        {
            SyntaxErrorList.Add(new Tuple<IRecognizer, IToken, int, int, string, RecognitionException>(
                recognizer, offendingSymbol, line, charPositionInLine, msg, e));
        }

        public List<Tuple<IRecognizer, IToken, int, int, string, RecognitionException>> getListOfErrors()
        {
            return this.SyntaxErrorList;
        }
    }
}
